<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <!-- -*- xhtml -*- -->
        <title>Getting Started Extending VisualVM</title>
        <link rel="stylesheet" type="text/css" href="http://www.netbeans.org/netbeans.css">
        <meta name="author" content="gwielenga@netbeans.org">
        <meta name="indexed" content="y">
        <meta name="description" content="A short guide to using the Visual VM API.">
    </head>
    <body>
        <h1>Getting Started Extending VisualVM</h1>
        
        <p>In this tutorial you will be
        introduced to the VisualVM APIs and you will be shown how to get
        started using them
        to extend VisualVM. In general, there are two types of use cases
        that apply to VisualVM extensions. Firstly, you have a monitoring
        or management tool that
        you want to make available to VisualVM. For example, maybe you have
        a tool that shows an application's threads or processing speed in a
        new and interesting way. In this case, you would create a plugin
        that makes your tool available to VisualVM via new tabs and menu
        items, so that VisualVM users can
        benefit from the feature set provided by your tool. Secondly, you
        have an application with specific monitoring/management needs. For
        example, if your application is a deployment server, you might want to 
        give users a graphic overview of the applications that are deployed
        to that server. In this case, you would need to introduce a new type
        of application to VisualVM. By default, all applications are treated
        in the same way and if, therefore, your application has one or more
        unique characteristics, you would need to provide for a unique type
        of application in this way.
        
        <h3>Contents</h3>
        <table border="0" cellpadding="0" cellspacing="0" width="100%">
            <tbody><tr>
                    <td align="left" valign="top">
                        <ul>
                            <li><a href="#understanding">Understanding the VisualVM APIs</a>
                            <li><a href="#preparing">Preparing to Extend VisualVM</a></li>
                            <li><a href="#hello">Creating a "Hello World" Plugin</a></li>
                            <li><a href="#further">Further Reading</a></li>
                        </ul> 
                    </td>
                </tr>
        </tbody></table>
        
        <h2 class="tutorial"><a name="understanding"></a>Understanding the VisualVM APIs</h2>
        
        <p>Entry points into VisualVM fall into the
        following categories, each implemented by the factory pattern:
        
        <ul>
            <li><b>Tab extension.</b> By default, VisualVM provides tabs
            with labels such as "Overview", "Monitor", and "Threads". You can
            create new tabs just like these. Optionally, your own tabs can be
            extendable so that others can plug subtabs into your tabs.
            Your tabs can either be available
            to all application types or to specific application types.
            <li><b>Subtab extension.</b> Within the three existing tabs
            listed above, you can provide
            new subtabs. You can also specify the new subtab's 
            position within the tab.
            Subtabs can either be
            available to all application types or to specific application
            types.
            <li><b>Menu extension.</b> An application type, and its subnodes,
            can have one or more menu items added to their contextual menus.
            <li><b>Application type extension.</b> Not only can you extend
            existing application types, as described above, but you can also
            create an entire new application type. You can do this to do 
            something as simple as provide a distinguishing icon for a
            running instance of your application. Alternatively, you might
            want to provide a lot of functionality, including graphs, to show
            the processing of your application. The starting point for this
            application-specific functionality is to implement a new
            application type.
        </ul>    
        
        <p>A visual representation of the entry points into VisualVM:
        
        <p><img src="http://blogs.sun.com/geertjan/resource/big-entrypoints-diagram.png" border="1">
        
        <p>Entry points into VisualVM are implemented via the factory
        pattern. In that light, the main VisualVM APIs are as follows:
        
        <ul>
            <li>Tabs
            <br><tt>com.sun.tools.visualvm.core.ui.DataSourceViewsProvider
            <br>/com.sun.tools.visualvm.core.ui.DataSourceView</tt>
            <p>To make your tabs extendable, the following API is needed:
            <br><tt>com.sun.tools.visualvm.core.ui.PluggableViewSupport</tt>
            <li>Subtabs
            <br><tt>com.sun.tools.visualvm.core.ui.ViewPlugin
            <br>/com.sun.tools.visualvm.core.ui.ViewPlugin.ViewDescriptor</tt>
            <li>Menu Items
            <br><tt>com.sun.tools.visualvm.core.explorer.ExplorerActionsProvider
            <br>/javax.swing.AbstractAction</tt>
            <li>Application Types
            <br><tt>com.sun.tools.visualvm.core.model.apptype.ApplicationTypeFactory
            <br>/com.sun.tools.visualvm.core.model.apptype.ApplicationType</tt>
            
        </ul>    
        
        <p>The lifecycle of a VisualVM plugin is determined by a <tt>ModuleInstall</tt> class,
        which comes from the NetBeans APIs. Whenever you implement a new entry point into
        VisualVM, you need to provide code for registering and unregistering the entry point
        implementation. The relevant initialization code must be provided in the <tt>ModuleInstall</tt>
        class. When the plugin is loaded into VisualVM, the <tt>ModuleInstall.restored</tt>
        method is the first method that is called from your plugin. That is the method
        that should initialize the entry points. When the plugin is uninstalled, or when VisualVM
        closes down, the plugin's entry points need to be deregistered, from the
        <tt>ModuleInstall.uninstalled</tt> method. You will be shown some typical
        registration/deregistration code in the "Hello World" scenario that follows.
        
        <p>A brief overview of the packages provided by the VisualVM APIs:
        <ul>
            <li><b>com.sun.tools.visualvm.core.datasource.</b>
            <li><b>com.sun.tools.visualvm.core.datasupport.</b>
            <li><b>com.sun.tools.visualvm.core.dataview.monitor.</b>
            <li><b>com.sun.tools.visualvm.core.dataview.overview.</b>
            <li><b>com.sun.tools.visualvm.core.dataview.threads.</b>
            <li><b>com.sun.tools.visualvm.core.explorer.</b>
            <li><b>com.sun.tools.visualvm.core.heapdump.</b>
            <li><b>com.sun.tools.visualvm.core.model.</b>
            <li><b>com.sun.tools.visualvm.core.model.apptype.</b>
            <li><b>com.sun.tools.visualvm.core.model.dsdescr.</b>
            <li><b>com.sun.tools.visualvm.core.model.host.</b>
            <li><b>com.sun.tools.visualvm.core.model.jmx.</b>
            <li><b>com.sun.tools.visualvm.core.model.jvm.</b>
            <li><b>com.sun.tools.visualvm.core.scheduler.</b>
            <li><b>com.sun.tools.visualvm.core.snapshot.</b>
            <li><b>com.sun.tools.visualvm.core.threaddump.</b>
            <li><b>com.sun.tools.visualvm.core.ui.</b>
            <li><b>com.sun.tools.visualvm.core.ui.components.</b>
        </ul>
        
        <h2><a name="preparing"></a>Preparing to Extend VisualVM</h2>
        
        <p>When you are planning to extend VisualVM, you need to
        do the following:
        
        <ul>
            
            <li><b>Install JDK 6.</b> VisualVM itself runs on JDK 6, even
            though it can monitor and manage applications running
            on earlier versions of the JDK. The plugins that you
            create need to therefore also make use of JDK 6 and
            not any earlier version of the JDK.
            
            <li><b>Install NetBeans IDE 6.0.</b> Though you are free to use
            any editor or IDE to develop VisualVM plugins, NetBeans IDE
            is optimized for plugin development for VisualVM. For example,
            the VisualVM plugin project structure, as well as several
            useful templates, can be generated by NetBeans IDE. At the
            time of writing, similar code generating features for VisualVM
            are not supported by other IDEs.
            
            <li><b>Register VisualVM in NetBeans IDE.</b> You will be
            building your VisualVM plugins against VisualVM, so that its
            plugins (and the APIs exposed by those plugins) are available
            to your own plugins. When you put the binary of VisualVM in the
            NetBeans Platform Manager, you will enable NetBeans IDE to compile
            your plugin against VisualVM. The VisualVM's APIs are then available 
            to your plugin. Under the Tools menu, choose NetBeans Platform
            Manager, and then browse to the root folder of your VisualVM
            installation. Click Next and then click Finish. Later, when you create
            a VisualVM plugin project, you will be able to specify that the
            plugin should be built against the VisualVM binary that you
            registered above.
            
            <li><b>Get the VisualVM Javadoc.</b> Get these from the "Milestone 3 API Docs"
                link on the <a href="https://visualvm.dev.java.net/">https://visualvm.dev.java.net/</a>
            page.</li>
            
            
            
        </ul>
        
        
        <h2><a name="hello"></a>Creating a "Hello World" Plugin</h2>
        
        
        <p>Now, we'll say "Hello World". We will create a new tab that looks as follows:
        
        <p><img src="http://blogs.sun.com/geertjan/resource/extend-visualvm-7.png" border="1"/>
        
        <p>There will be no data in our tab, we'll simply create it and add 
        some placeholders for content. 
        
        <ol>
            <p><li>In NetBeans IDE, choose File &gt; New Project and then
            choose NetBeans Modules &gt; Module. Click Next. Create a new NetBeans module and make 
            sure to specify that 
            you want to build against the VisualVM binary that you registered earlier:
            
            <p><p><img src="http://blogs.sun.com/geertjan/resource/extend-visualvm-4.png" border="1"/>
            
            <p>Click Next and fill out the next step in way you like. Click Finish.
            
            <p><li>Use the "Module Installer" wizard, which will create the class that is called
            when the plugin is installed into VisualVM. Here's where you'll find the wizard 
            in the New File dialog:
            
            <p><p><img src="http://blogs.sun.com/geertjan/resource/extend-visualvm-5.png" border="1"/>
            
            <p><li>Once you've completed the wizard, implement the <tt>ModuleInstall.restored</tt> 
            method and the <tt>ModuleInstall.uninstalled</tt> methods as follows:
            
            <p><pre>@Override
public void restored() {
    HelloWorldViewProvider.initialize();
}

@Override
public void uninstalled() {
    HelloWorldViewProvider.unregister();
            }</pre>
            
            <p>As you can see, we will define the above two methods in a class called "HelloWorldViewProvider",
            which we will define later. Therefore you can ignore the red error lines, because you
            will create the methods later.
            
            <p><li>Now add a dependency on "VisualVM-Core", which provides the APIs into the VisualVM.
            Do this by right-clicking the project node, choosing "Properties", and then setting
            the dependency in the "Libraries" tab.
            
            <p><li>Create a class called "HelloViewProvider", as follows:
            
            <p><pre>class HelloWorldViewProvider implements DataSourceViewsProvider&lt;Application&gt; {

    private Map&lt;Application, DataSourceView&gt; viewsCache = new HashMap();
    private static DataSourceViewsProvider&lt;Application&gt; instance =  new HelloWorldViewProvider();

    <b>@Override</b>
    public boolean supportsViewFor(Application application) {
        //Always shown:
        return true;
    }

    <b>@Override</b>
    public synchronized Set<? extends DataSourceView> getViews(final Application application) {
        
        DataSourceView view = viewsCache.get(application);
        
        if (view == null) {
            view = new HelloWorldView(application) {
                @Override
                public void removed() {
                    super.removed();
                    viewsCache.remove(application);
                }
            };
            viewsCache.put(application, view);
        }
        
        return Collections.singleton(view);
    }

    static void initialize() {
        DataSourceWindowFactory.sharedInstance().addViewProvider(instance, Application.class);
    }
    
    static void unregister() {
        DataSourceWindowFactory.sharedInstance().removeViewProvider(instance);
    }
    
            }</pre>
            
            <p>By reading the Javadoc that you downloaded earlier, you'll 
            know what the two overridden methods above are all about:
            
            <p><p><img src="http://blogs.sun.com/geertjan/resource/extend-visualvm-6.png" border="1"/>
            
            <p><li>Finally, we'll create our <tt>HelloView</tt> class, which is created by our provider above:
            
            <p><pre>class HelloWorldView extends DataSourceView {

    private DataViewComponent dvc;
    private Application application;
    private DataViewComponent view;
    //Make sure there is an image at this location in your project:
    private static final String IMAGE_PATH = "org/hellovisualvm/icon.png"; // NOI18N

    public HelloWorldView(Application application) {
        super("Hello World", new ImageIcon(Utilities.loadImage(IMAGE_PATH, true)).getImage(), 60);
        this.application = application;
        view = createViewComponent();
    }

    <b>@Override</b>
    public DataViewComponent getView() {
        return view;
    }

    private DataViewComponent createViewComponent() {

        <b>//Data area for master view:</b>
        JEditorPane generalDataArea = new JEditorPane();
        generalDataArea.setBorder(BorderFactory.createEmptyBorder(14, 8, 14, 8));

        <b>//Panel, which we'll reuse in all four of our detail views for this sample:</b>
        JPanel panel = new JPanel();

        <b>//Master view:</b>
        DataViewComponent.MasterView masterView = new DataViewComponent.MasterView
                ("Hello World Overview", null, generalDataArea);

        <b>//Configuration of master view:</b>
        DataViewComponent.MasterViewConfiguration masterConfiguration = 
                new DataViewComponent.MasterViewConfiguration(false);

        <b>//Add the master view and configuration view to the component:</b>
        dvc = new DataViewComponent(masterView, masterConfiguration);

        <b>//Add configuration details to the component, which are the show/hide checkboxes at the top:</b>
        dvc.configureDetailsArea(new DataViewComponent.DetailsAreaConfiguration(
                "Hello World Details 1", true), DataViewComponent.TOP_LEFT);
        dvc.configureDetailsArea(new DataViewComponent.DetailsAreaConfiguration(
                "Hello World Details 2", true), DataViewComponent.TOP_RIGHT);
        dvc.configureDetailsArea(new DataViewComponent.DetailsAreaConfiguration(
                "Hello World Details 3 & 4", true), DataViewComponent.BOTTOM_RIGHT);

        <b>//Add detail views to the component:</b>

        dvc.addDetailsView(new DataViewComponent.DetailsView(
                "Hello World Details 1", null, panel, null), DataViewComponent.TOP_LEFT);
        dvc.addDetailsView(new DataViewComponent.DetailsView(
                "Hello World Details 2", null, panel, null), DataViewComponent.TOP_RIGHT);
        dvc.addDetailsView(new DataViewComponent.DetailsView(
                "Hello World Details 3", null, panel, null), DataViewComponent.BOTTOM_RIGHT);
        dvc.addDetailsView(new DataViewComponent.DetailsView(
                "Hello World Details 4", null, panel, null), DataViewComponent.BOTTOM_RIGHT);

        return dvc;

    }
    
            }</pre>
            
            <p><li>Right-click the project node and choose "Run".
            This will install the plugin in a new instance of VisualVM
            and you'll see your new tab, for all application types:
            
            <p><p><img src="http://blogs.sun.com/geertjan/resource/extend-visualvm-7.png" border="1"/>
            
        </ol>
        <p>Congratulations you have completed the Hello World scenario!
        
        <h2><a name="further"></a>Further Reading</h2>
        
        <p>To continue learning about the VisualVM APIs, you are
        recommended to consult the following resources:
        
        <ol>
            <li><b>VisualVM Javadoc.</b> Get these from the "Milestone 3 API Docs"
                link on the <a href="https://visualvm.dev.java.net/">https://visualvm.dev.java.net/</a>
            page.</li>
            <li><b>VisualVM Plugins.</b> When you download the VisualVM
                sources, you will find that you have also downloaded the sources
                of a set of plugins. You can inspect these plugins and learn
                from them. At the time of writing, these plugins were as follows:
                <p><ul>
                    <li><b>GlassFish.</b> This plugin provides a new application
                        type for the GlassFish server. A new application type node
                        is created for each running GlassFish instance. All deployed
                        applications are represented by subnodes, with further subnodes
                        for each servlet in the application. Furthermore, tabs specific
                        to each server instance, application, and servlet are also
                    provided.</li>
                    <li><b>MBeans.</b> This plugin provides a new tab for all
                    applications that have JMX enabled. The information provided
                    in the tab is exactly the same as the information provided by
                    the MBeans tab in the JDK's JConsole application.
                    <li><b>JConsole.</b> This plugin makes VisualVM receptive
                    to JConsole plugins, so that investment in JConsole plugins is
                    not lost when you transfer from JConsole to VisualVM.
                </ul>
                
            </li> 
            <li><b>Blog entries by Geertjan Wielenga.</b> Geertjan is
                the technical writer responsible for documenting the VisualVM APIs.
                While learning about the VisualVM APIs, he wrote a series of blog
                entries about the VisualVM APIs he was learning about. The relevant
                blog entries are as follows:
                <p><ul>
                    <li><b><a href="http://blogs.sun.com/geertjan/entry/getting_started_extending_visualvm"> Getting Started Extending VisualVM (Part 1)</a>.</b>
                    Here you create your first tab extension. You discover that VisualVM
                    tabs are broken down into master views, master view configurations,
                    and detail views. That blog entry is reproduced in the "Hello World"
                    section of this tutorial.
                    <li><b><a href="http://blogs.sun.com/geertjan/entry/getting_started_extending_visualvm_part">Getting Started Extending VisualVM (Part 2)</a>.</b>
                    Here you create an application type extension, with a subtab
                    extension within the Overview tab and a menu extension, both specifically 
                    for the application type.
                    <li><b><a href="http://blogs.sun.com/geertjan/entry/getting_started_extending_visualvm_part1">Getting Started Extending VisualVM (Part 3)</a>.</b>
                    Here you are introduced to application type subnodes and you
                    are referred to the GlassFish plugin for related source code.
                    <li><b><a href="http://blogs.sun.com/geertjan/entry/getting_started_extending_visualvm_part2">Getting Started Extending VisualVM (Part 4)</a>.</b>
                    Here the extendability of the "Overview" tab, "Monitor" tab, and "Threads" tab
                    are highlighted. In addition, you are shown how to make your own tabs
                    extendable.
                </ul>    
            </li>
            
        </ol>
        
        
        
    </body>
</html>
