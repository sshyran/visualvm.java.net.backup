<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <!-- -*- xhtml -*- -->
        <title>Getting Started Extending VisualVM</title>
        <link rel="stylesheet" type="text/css" href="http://www.netbeans.org/netbeans.css">
        <meta name="author" content="gwielenga@netbeans.org">
        <meta name="indexed" content="y">
        <meta name="description" content="A short guide to using the Visual VM API.">
    </head>
    <body>
        <h1>Getting Started Extending VisualVM</h1>
        
        <p>In this tutorial you will be
        introduced to the VisualVM APIs and you will be shown how to get
        started using them
        to extend VisualVM. In general, there are two types of use cases
        that apply to VisualVM extensions. Firstly, you have a monitoring
        or management tool that
        you want to make available to VisualVM. For example, maybe you have
        a tool that shows an application's threads or processing speed in a
        new and interesting way. In this case, you would create a plugin
        that makes your tool available to VisualVM via new tabs and menu
        items, so that VisualVM users can
        benefit from the feature set provided by your tool. Secondly, you
        have an application with specific monitoring/management needs. For
        example, if your application is a deployment server, you might want to 
        give users a graphic overview of the applications that are deployed
        to that server. In this case, you would need to introduce a new type
        of application to VisualVM. By default, all applications are treated
        in the same way and if, therefore, your application has one or more
        unique characteristics, you would need to provide for a unique type
        of application in this way.
        
        
        <p>Entry points into VisualVM fall into the
        following categories, each implemented by the factory pattern:
        
        <ul>
            <li><b>Tab extension.</b> By default, VisualVM provides tabs
            with labels such as "Overview", "Monitor", and "Threads". You can
            create new tabs just like these. Your tabs can either be available
            to all application types or to specific application types.
            <li><b>Overview tab extension.</b> By default, the application
            types all share an "Overview" tab, which lists JVM arguments and
            other high level application-specific information. You can provide
            new subtabs within the Overview tab, which can either be
            available to all appllication types or to specific application
            types.
            <li><b>Menu extension.</b> An application type, and its subnodes,
            can have one or more menu items added to their contextual menus.
            <li><b>Application type extension.</b> Not only can you extend
            existing application types, as described above, but you can also
            create an entire new application type. You can do this to do 
            something as simple as provide a distinguishing icon for a
            running instance of your application. Alternatively, you might
            want to provide a lot of functionality, including graphs, to show
            the processing of your application. The starting point for this
            application-specific functionality is to implement a new
            application type.
        </ul>    
        
        <p>A visual representation of the entry points into VisualVM:
        
        <p><img src="http://blogs.sun.com/geertjan/resource/big-entrypoints-diagram.png" border="1">
        
        <p>The lifecycle of a VisualVM plugin is determined by a <tt>ModuleInstall</tt> class,
        which comes from the NetBeans APIs. Whenever you implement a new entrypoint into
        VisualVM, you need to provide code for registering and unregistering the entrypoint
        implementation. The relevant initialization code must be provided in the <tt>ModuleInstall</tt>
        class. When the plugin is loaded into VisualVM, the <tt>ModuleInstall.restored</tt>
        method is the first method that is called from your plugin. That is the method
        that should initialize the entrypoints. When the plugin is uninstalled, or when VisualVM
        closes down, the plugin's entrypoints need to be deregistered, from the
        <tt>ModuleInstall.uninstalled</tt> method. You will be shown some typical
        registration/deregistration code in the "Hello World" scenario that follows.
        
        
        <h2>Preparing to Extend VisualVM</h2>
        
        <p>When you are planning to extend VisualVM, you need to
        do the following:
        
        <ul>
            
            <li><b>Install JDK 6.</b> VisualVM itself runs on JDK 6, even
            though it can monitor and manage applications running
            on earlier versions of the JDK. The plugins that you
            create need to therefore also make use of JDK 6 and
            not any earlier version of the JDK.
            
            <li><b>Install NetBeans IDE 6.0.</b> Though you are free to use
            any editor or IDE to develop VisualVM plugins, NetBeans IDE
            is optimized for plugin development for VisualVM. For example,
            the VisualVM plugin project structure, as well as several
            useful templates, can be generated by NetBeans IDE. At the
            time of writing, similar code generating features for VisualVM
            are not supported by other IDEs.
            
            <li><b>Register VisualVM in NetBeans IDE.</b> You will be
            building your VisualVM plugins against VisualVM, so that its
            plugins (and the APIs exposed by those plugins) are available
            to your own plugins. When you put the binary of VisualVM in the
            NetBeans Platform Manager, you will enable NetBeans IDE to compile
            your plugin against VisualVM. The VisualVM's APIs are then available 
            to your plugin. Under the Tools menu, choose NetBeans Platform
            Manager, and then browse to the root folder of your VisualVM
            installation. Click Next and then click Finish. Later, when you create
            a VisualVM plugin project, you will be able to specify that the
            plugin should be built against the VisualVM binary that you
            registered above.
            
            <li><b>Get the VisualVM Javadoc.</b> Get these from the "Milestone 3 API Docs"
            link on the <a href="https://visualvm.dev.java.net/">https://visualvm.dev.java.net/</a>
            page.</li>
            
            
            
        </ul>
        
        
        <h2>Hello World</h2>
        
        
        <p>Now, we'll say "Hello World". We will create a new tab that looks as follows:

<p><img src="http://blogs.sun.com/geertjan/resource/extend-visualvm-7.png" border="1"/>

<p>There will be no data in our tab, we'll simply create it and add 
some placeholders for content. 

<ol>
<p><li>Create a new NetBeans module and make sure to specify that 
you want to build against the VisualVM binary that you registered earlier:

<p><p><img src="http://blogs.sun.com/geertjan/resource/extend-visualvm-4.png" border="1"/>

<p><li>Use the "Module Installer" wizard, which will create a class that is called
when the plugin is installed into VisualVM. Here's where you'll find the wizard 
in the New File dialog:

<p><p><img src="http://blogs.sun.com/geertjan/resource/extend-visualvm-5.png" border="1"/>

<p><li>Once you've completed the wizard, implement the <tt>ModuleInstall.restored</tt> 
method and the <tt>ModuleInstall.uninstalled</tt> methods as follows:

<p><pre>@Override
public void restored() {
    HelloWorldViewProvider.initialize();
}

@Override
public void uninstalled() {
    HelloWorldViewProvider.unregister();
}</pre>

<p><li>Now add a dependency on "VisualVM-Core", which provides the APIs into the VisualVM.
Do this by right-clicking the project node, choosing "Properties", and then setting
the dependency in the "Libraries" tab.

<p><li>Create a class called "HelloViewProvider", as follows:

<p><pre>class HelloWorldViewProvider implements DataSourceViewsProvider&lt;Application&gt; {

    private Map&lt;Application, DataSourceView&gt; viewsCache = new HashMap();
    private static DataSourceViewsProvider&lt;Application&gt; HelloWorldViewProvider =  new HelloWorldViewProvider();

    <b>@Override</b>
    public boolean supportsViewFor(Application application) {
        //Always shown:
        return true;
    }

    <b>@Override</b>
    public synchronized Set<? extends DataSourceView> getViews(final Application application) {
        
        DataSourceView view = viewsCache.get(application);
        if (view == null) {
            view = new HelloWorldView(application) {
                @Override
                public void removed() {
                    super.removed();
                    viewsCache.remove(application);
                }
            };
            viewsCache.put(application, view);
            
        }
        return Collections.singleton(view);
    }

    static void initialize() {
        DataSourceWindowFactory.sharedInstance().addViewProvider(
                HelloWorldViewProvider, Application.class);
    }
    
    static void unregister() {
        DataSourceWindowFactory.sharedInstance().removeViewProvider(
                HelloWorldViewProvider);
    }
    
}</pre>

<p>By reading the Javadoc that you downloaded earlier, you'll 
know what the two overridden methods above are all about:

<p><p><img src="http://blogs.sun.com/geertjan/resource/extend-visualvm-6.png" border="1"/>

<p><p>You should be using the following import statements at this point:

<p><pre>import com.sun.tools.visualvm.core.datasource.Application;
import com.sun.tools.visualvm.core.model.jmx.JmxModel;
import com.sun.tools.visualvm.core.model.jmx.JmxModelFactory;
import com.sun.tools.visualvm.core.ui.DataSourceView;
import com.sun.tools.visualvm.core.ui.DataSourceViewsProvider;
import com.sun.tools.visualvm.core.ui.DataSourceWindowFactory;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.management.MBeanServerConnection;</pre>

<p><li>Finally, we'll create our <tt>HelloView</tt> class, which is created by our provider above:

<p><pre>class HelloWorldView extends DataSourceView {

    private DataViewComponent dvc;
    private Application application;
    private DataViewComponent view;
    //Make sure there is an image at this location in your project:
    private static final String IMAGE_PATH = "org/hellovisualvm/icon.png"; // NOI18N

    public HelloWorldView(Application application) {
        super("Hello World", new ImageIcon(Utilities.loadImage(IMAGE_PATH, true)).getImage(), 60);
        this.application = application;
        view = createViewComponent();
    }

    <b>@Override</b>
    public DataViewComponent getView() {
        return view;
    }

    private DataViewComponent createViewComponent() {

        <b>//Data area for master view:</b>
        JEditorPane generalDataArea = new JEditorPane();
        generalDataArea.setBorder(BorderFactory.createEmptyBorder(14, 8, 14, 8));

        <b>//Panel, which we'll reuse in all four of our detail views for this sample:</b>
        JPanel panel = new JPanel();

        <b>//Master view:</b>
        DataViewComponent.MasterView masterView = new DataViewComponent.MasterView
                ("Hello World Overview", null, generalDataArea);

        <b>//Configuration of master view:</b>
        DataViewComponent.MasterViewConfiguration masterConfiguration = 
                new DataViewComponent.MasterViewConfiguration(false);

        <b>//Add the master view and configuration view to the component:</b>
        dvc = new DataViewComponent(masterView, masterConfiguration);

        <b>//Add configuration details to the component, which are the show/hide checkboxes at the top:</b>
        dvc.configureDetailsArea(new DataViewComponent.DetailsAreaConfiguration(
                "Hello World Details 1", true), DataViewComponent.TOP_LEFT);
        dvc.configureDetailsArea(new DataViewComponent.DetailsAreaConfiguration(
                "Hello World Details 2", true), DataViewComponent.TOP_RIGHT);
        dvc.configureDetailsArea(new DataViewComponent.DetailsAreaConfiguration(
                "Hello World Details 3 & 4", true), DataViewComponent.BOTTOM_RIGHT);

        <b>//Add detail views to the component:</b>

        dvc.addDetailsView(new DataViewComponent.DetailsView(
                "Hello World Details 1", null, panel, null), DataViewComponent.TOP_LEFT);
        dvc.addDetailsView(new DataViewComponent.DetailsView(
                "Hello World Details 2", null, panel, null), DataViewComponent.TOP_RIGHT);
        dvc.addDetailsView(new DataViewComponent.DetailsView(
                "Hello World Details 3", null, panel, null), DataViewComponent.BOTTOM_RIGHT);
        dvc.addDetailsView(new DataViewComponent.DetailsView(
                "Hello World Details 4", null, panel, null), DataViewComponent.BOTTOM_RIGHT);

        return dvc;

    }
    
}</pre>

<p><li>Right-click the project node and choose "Run".
This will install the plugin in a new instance of VisualVM
and you'll see your new tab, for all application types:

<p><p><img src="http://blogs.sun.com/geertjan/resource/extend-visualvm-7.png" border="1"/>

</ol>
        <p>Congratulations you have completed the Hello World scenario!
        
        <h2>Further Reading</h2>
        
        <p>To continue learning about the VisualVM APIs, you are
        recommended to consult the following resources:
        
        <ol>
            <li><b>VisualVM Javadoc.</b> Get these from the "Milestone 3 API Docs"
            link on the <a href="https://visualvm.dev.java.net/">https://visualvm.dev.java.net/</a>
            page.</li>
            <li><b>VisualVM Plugins.</b> When you download the VisualVM
                sources, you will find that you have also downloaded the sources
                of a set of plugins. You can inspect these plugins and learn
                from them. At the time of writing, these plugins were as follows:
                <p><ul>
                    <li><b>GlassFish.</b> This plugin provides a new application
                        type for the GlassFish server. A new application type node
                        is created for each running GlassFish instance. All deployed
                        applications are represented by subnodes, with further subnodes
                        for each servlet in the application. Furthermore, tabs specific
                        to each server instance, application, and servlet are also
                    provided.</li>
                    <li><b>MBeans.</b> This plugin provides a new tab for all
                    applications that have JMX enabled. The information provided
                    in the tab is exactly the same as the information provided by
                    the MBeans tab in the JDK's JConsole application.
                    <li><b>JConsole.</b> This plugin makes VisualVM receptive
                    to JConsole plugins, so that investment in JConsole plugins is
                    not lost when you transfer from JConsole to VisualVM.
                </ul>
                
            </li> 
            <li><b>Blog entries by Geertjan Wielenga.</b> Geertjan is
                the technical writer responsible for documenting the VisualVM APIs.
                While learning about the VisualVM APIs, he wrote a series of blog
                entries about the VisualVM APIs he was learning about. The relevant
                blog entries are as follows:
                <p><ul>
                    <li><b><a href="http://blogs.sun.com/geertjan/entry/getting_started_extending_visualvm"> Getting Started Extending VisualVM (Part 1)</a>.</b>
                    Here you create your first tab extension. You discover that VisualVM
                    tabs are broken down into master views, master view configurations,
                    and detail views. That blog entry is reproduced in the "Hello World"
                    section of this tutorial.
                    <li><b><a href="http://blogs.sun.com/geertjan/entry/getting_started_extending_visualvm_part">Getting Started Extending VisualVM (Part 2)</a>.</b>
                    Here you create an application type extension, with an overview
                    extension and menu extension specifically for the application type.
                    <li><b><a href="http://blogs.sun.com/geertjan/entry/getting_started_extending_visualvm_part1">Getting Started Extending VisualVM (Part 3)</a>.</b>
                    Here you are introduced to application type subnodes and you
                    are referred to the GlassFish plugin for related source code.
                </ul>    
            </li>
            
        </ol>
        
        
        
    </body>
</html>
