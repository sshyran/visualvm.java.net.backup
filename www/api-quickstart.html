<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <!-- -*- xhtml -*- -->
        <title>Getting Started Extending VisualVM</title>
        <link rel="stylesheet" type="text/css" href="http://www.netbeans.org/netbeans.css">
        <meta name="author" content="gwielenga@netbeans.org">
        <meta name="indexed" content="y">
        <meta name="description" content="A short guide to using the Visual VM API.">
    </head>
    <body>
        <h1>Getting Started Extending VisualVM</h1>
        
        <p>In this tutorial you will be
        introduced to the VisualVM APIs and you will be shown how to get
        started using them
        to extend VisualVM. In general, there are two types of use cases
        that apply to VisualVM extensions. Firstly, you have a monitoring
        or management tool that
        you want to make available to VisualVM. For example, maybe you have
        a tool that shows an application's threads or processing speed in a
        new and interesting way. In this case, you would create a plugin
        that makes your tool available to VisualVM via new tabs and menu
        items, so that its users can
        benefit from the feature set provided by your tool. Secondly, you
        have an application with specific monitoring/management needs. For
        example, if your application is a deployment server, you might want to 
        give users a graphic overview of the applications that are deployed
        to that server. In this case, you would need to introduce a new type
        of application to VisualVM. By default, all applications are treated
        in the same way and if, therefore, your application has one or more
        unique characteristics, you would need to provide for a unique type
        of application in this way.
        
        
        <p>Entry points into VisualVM fall into the
        following categories, each implemented by the factory pattern:
        
        <ul>
            <li><b>Tab extension.</b> By default, VisualVM provides tabs
            with labels such as "Overview", "Monitor", and "Threads". You can
            create new tabs just like these. Your tabs can either be available
            to all application types or to specific application types.
            <li><b>Overview tab extension.</b> By default, the application
            types all share an "Overview" tab, which lists JVM arguments and
            other high level application-specific inormation. You can provide
            new subtabs within the Overview tab, which can either be
            available to all appllication types or to specific application
            types.
            <li><b>Menu extension.</b> An application type, and its subnodes,
            can have one or more menu items added to their contextual menus.
            <li><b>Application type extension.</b> Not only can you extend
            existing application types, as described above, but you can also
            create an entire new application type. You can do this to do 
            something as simple as provide a distinguishing icon for a
            running instance of your application. Alternatively, you might
            want to provide a lot of functionality, including graphs, to show
            the processing of your application. The starting point for this
            application-specific functionality is to implement a new
            application type.
        </ul>    
        
        <p>A visual representation of the entry points into VisualVM:
        
        <p><a href="http://blogs.sun.com/geertjan/resource/big-entrypoints-diagram.png"><img src="http://blogs.sun.com/geertjan/resource/extend-visualvm-3.png" border="1"></a>
        
        <p>The lifecycle of a VisualVM plugin is determined by a <tt>ModuleInstall</tt> class,
        which comes from the NetBeans APIs. Whenever you implement a new entrypoint into
        VisualVM, you need to provide code for registering and unregistering the entrypoint
        implementation. The relevant initialization code must be provided in the <tt>ModuleInstall</tt>
        class. When the plugin is loaded into VisualVM, the <tt>ModuleInstall.restored</tt>
        method is the first method that is called from your plugin. That is the method
        that should initialize the entrypoints. When the plugin is uninstalled, or when VisualVM
        closes down, the plugin's entrypoints need to be deregistered, from the
        <tt>ModuleInstall.uninstalled</tt> method. You will be shown some typical
        registration/deregistration code in the "Hello World" scenario that follows.
        
        
        <h2>Preparing to Extend VisualVM</h2>
        
        <p>When you are planning to extend VisualVM, you need to
        configure an environment that includes the following:
        
        <ul>
            
            <li><b>Install JDK 6.</b> VisualVM itself runs on JDK 6, even
            though it can monitor and manage applications running
            on earlier versions of the JDK. The plugins that you
            create need to therefore also make use of JDK 6 and
            not any earlier version of the JDK.
            
            <li><b>Install NetBeans IDE 6.0.</b> Though you are free to use
            any editor or IDE to develop VisualVM plugins, NetBeans IDE
            is optimized for plugin development for VisualVM. For example,
            the VisualVM plugin project structure, as well as several
            useful templates, can be generated by NetBeans IDE. At the
            time of writing, similar code generating features for VisualVM
            are not supported by other IDEs.
            
            <li><b>Register VisualVM in NetBeans IDE.</b> You will be
            building your VisualVM plugins against VisualVM, so that its
            plugins (and the APIs exposed by those plugins) are available
            to your own plugins. When you put the binary of VisualVM in the
            NetBeans Platform Manager, you will enable NetBeans IDE to compile
            your plugin against VisualVM. The VisualVM's APIs are then available 
            to your plugin. Under the Tools menu, choose NetBeans Platform
            Manager, and then browse to the root folder of your VisualVM
            installation. Click Next and then click Finish. Later, when you create
            a VisualVM plugin project, you will be able to specify that the
            plugin should be built against the VisualVM binary that you
            registered above.
            
            
            
            
            
        </ul>
        
        
        <h2>Hello World</h2>
        
        <h2>Further Reading</h2>
        
        <p>To continue learning about the VisualVM APIs, you are
        recommended to consult the following resources:
        
        <ol>
            <li><b>VisualVM Javadoc.</b></li>
            <li><b>VisualVM Plugins.</b> When you download the VisualVM
                sources, you will find that you have also downloaded the sources
                of a set of plugins. You can inspect these plugins and learn
                from them. At the time of writing, these plugins were as follows:
                <p><ul>
                    <li><b>GlassFish.</b> This plugin provides a new application
                        type for the GlassFish server. A new application type node
                        is created for each running GlassFish instance. All deployed
                        applications are represented by subnodes, with further subnodes
                        for each servlet in the application. Furthermore, tabs specific
                        to each server instance, application, and servlet are also
                    provided.</li>
                    <li><b>MBeans.</b> This plugin provides a new tab for all
                    applications that have JMX enabled. The information provided
                    in the tab is exactly the same as the information provided by
                    the MBeans tab in the JDK's JConsole application.
                    <li><b>JConsole.</b> This plugin makes VisualVM receptive
                    to JConsole plugins, so that investment in JConsole plugins is
                    not lost when you transfer from JConsole to VisualVM.
                </ul>
                
            </li> 
            <li><b>Blog entries by Geertjan Wielenga.</b> Geertjan is
                the technical writer responsible for documenting the VisualVM APIs.
                While learning about the VisualVM APIs, he wrote a series of blog
                entries about the VisualVM APIs he was learning about. The relevant
                blog entries are as follows:
                <p><ul>
                    <li><b><a href="http://blogs.sun.com/geertjan/entry/getting_started_extending_visualvm"> Getting Started Extending VisualVM (Part 1)</a>.</b>
                    Here you create your first tab extension. You discover that VisualVM
                    tabs are broken down into master views, master view configurations,
                    and detail views.
                    <li><b><a href="http://blogs.sun.com/geertjan/entry/getting_started_extending_visualvm_part">Getting Started Extending VisualVM (Part 2)</a>.</b>
                    Here you create an application type extension, with an overview
                    extension and menu extension specifically for the application type.
                    <li><b><a href="http://blogs.sun.com/geertjan/entry/getting_started_extending_visualvm_part1">Getting Started Extending VisualVM (Part 3)</a>.</b>
                    Here you are introduced to application type subnodes and you
                    are referred to the GlassFish plugin for related source code.
                </ul>    
            </li>
            
        </ol>
        
        
        
    </body>
</html>
