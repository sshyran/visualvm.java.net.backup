<html>
    <head>
        <title>VisualVM Profiler Tab</title>
        <link rel="stylesheet" type="text/css" href="default.css">
    </head>
    <body>
        <h2>Profiler Tab</h2>
        <p>VisualVM presents data for local and remote applications in a tab specific for that application.
        When you open an application in VisualVM, each application opens in a new tab in the main window.
        You can have multiple application tabs open.</p>
        <p>Each application tab contains sub-tabs that display different types of 
        information about the application.</p>

        <p>The Profiler tab enables you to profile local applications to view data on CPU performance and memory usage.
        By default the profiling tool is not running until you are ready to profile the application.
        You can choose from the following profiling options:</p>
        <ul>
            <li><b>CPU.</b> Choose this to profile the performance of the application. 
            These are the figures that a Java application can obtain using the java.lang.Runtime.totalMemory() and java.lang.Runtime.freeMemory() calls.</li>
            <li><b>Memory.</b> Choose this to analyze the memory usage of the application.</li>
        </ul>
        
        <h3>Toolbar</h3>
        <p>When profiling an application, profiling results are displayed in the Profiler tab.
        The Profiler tab contains a tool bar for working with profiling results.</p>
        <ul>
            <li><b>Autorefresh.</b>
            Click to activate and deactivate Autorefresh of results. 
            When active, the displayed profiling results are automatically updated at short intervals (about 2 seconds). </li>
            <!--<li><b>Take Snapshot</b>
            Click this button takes a snapshot of the current profile data. When you take a snapshot, the snapshot is opened in a new tab in the Source Editor.</li>-->
            <li><b>Reset Collected Results.</b>
            Click to discard the already accumulated profiling results.</li>
            <li><b>Run GC.</b>
            Click to run garbage collection.</li>
        </ul>
        
        <h3>Filtering results</h3>
        <p>The filter box below the profiling results enables you to filter the displayed results according to the name of the method. 
        To filter the results, enter a term in the method name filter box, select which filtering method to use and press Return. 
        You can see and select previous filter terms by clicking the arrow to the right of the method name filter box.

To restore the full unfiltered list of methods, click Clear Filter ( Clear Filter ) to the right of the method name filter box.
        
        
        <h3>CPU</h3>
        <p>This profile command returns detailed data on method-level CPU performance (execution time), showing the total execution time and number of invocations for each method.
        You can choose to analyze the entire application, part of the application, or startup performance.</p>
        <p>When analyzing application performance, VisualVM instruments all of the methods of the profiled application. 
        Threads emit the "method entry" event when entering a method and generate the corresponding "method exit" event when exiting the method. 
        Both of these events contain timestamps. This data is processed in real time.</p>

<p>When profiling applications that are deployed to a server (such as enterprise applications and web modules) or NetBeans modules or suites deployed to the NetBeans platform, 
you have the option to also profile the server or platform startup. 
When this option is selected, the first method executed by the JVM is used as the root method when instrumenting. </p>
        
        
        <h3>Memory</h3>
        <p>When you analyse memory usage, the total number of objects allocated by each class (including array classes) is displayed in a table. 
        The allocated objects are displayed for each currently loaded class and for any new classes as they are loaded.
        The results display the number of objects as an absolute number and as a percentage 
        The allocated bytes by each class are also displayed, as a graph representing the percentage of bytes as well as the total number of bytes allocated by each class.
        </p>

        <p>When you profile memory usage, the profiling results display a list of classes , 
        with the total size and number of instances that have been allocated since you issued the instrumentation command.  

        When you start profiling, all classes currently loaded by the target JVM (and each new class as it is loaded)
        are instrumented to produce information about object allocations. 
        The number of object allocations that Profiler presents is exact.</p>
        
        
    </body>
</html>
